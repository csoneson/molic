# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

any_true <- function(v) {
    .Call('_molic_any_true', PACKAGE = 'molic', v)
}

pairwise_comb <- function(x) {
    .Call('_molic_pairwise_comb', PACKAGE = 'molic', x)
}

count_unique <- function(x) {
    .Call('_molic_count_unique', PACKAGE = 'molic', x)
}

matpr <- function(A) {
    .Call('_molic_matpr', PACKAGE = 'molic', A)
}

dfs <- function(adj, root) {
    .Call('_molic_dfs', PACKAGE = 'molic', adj, root)
}

n_a <- function(A) {
    .Call('_molic_n_a', PACKAGE = 'molic', A)
}

na_ya <- function(na, ya) {
    .Call('_molic_na_ya', PACKAGE = 'molic', na, ya)
}

n_b <- function(na, b) {
    .Call('_molic_n_b', PACKAGE = 'molic', na, b)
}

subtract_one <- function(x) {
    .Call('_molic_subtract_one', PACKAGE = 'molic', x)
}

Gx_ <- function(x) {
    .Call('_molic_Gx_', PACKAGE = 'molic', x)
}

Hx_ <- function(x) {
    .Call('_molic_Hx_', PACKAGE = 'molic', x)
}

subM <- function(A, x) {
    .Call('_molic_subM', PACKAGE = 'molic', A, x)
}

#' Marginal tables
#'
#' Returns a list with sparse marginal tables corresponding to variables in list \code{am}
#'
#' @param A character matrix (the data)
#' @param am A list of variables (typically cliques or separators with RIP ordering)
#'
#' @export
a_marginals <- function(A, am) {
    .Call('_molic_a_marginals', PACKAGE = 'molic', A, am)
}

#' T(y)
#'
#' Calculate the affine value T(y) of -2log likelihood-ratio statistic
#'
#' @param y A named (according to data) vector
#' @param C_marginals Clique marginal tables (use a_marginals function)
#' @param S_marginals Separator marginal tables (use a_marginals function)
#'
#' @export
TY <- function(y, C_marginals, S_marginals) {
    .Call('_molic_TY', PACKAGE = 'molic', y, C_marginals, S_marginals)
}

#' Maximum Cardinality Search
#' 
#' @param adj A named adjacency list of a decomposable grah
#' @details If adj is not the adjacency list of a decomposable graph and error is produced
#' @return A list with a perfect numbering of the nodes and a perfect sequence of sets
#' @export
mcs <- function(adj) {
    .Call('_molic_mcs', PACKAGE = 'molic', adj)
}

perfect_cliques <- function(x) {
    .Call('_molic_perfect_cliques', PACKAGE = 'molic', x)
}

perfect_separators <- function(x) {
    .Call('_molic_perfect_separators', PACKAGE = 'molic', x)
}

#' Runnining Intersection Property
#'
#' Given a decomposable graph, this functions finds a perfect numbering on the vertices using maximum cardinality search, and hereafter returns a list with two elements: "C" - A RIP-ordering of the cliques and "S" - A RIP ordering of the separators.
#'
#' @param adj A named adjacency list of a decomposable graph
#' @export
rip <- function(adj) {
    .Call('_molic_rip', PACKAGE = 'molic', adj)
}

set_intersect <- function(v1, v2) {
    .Call('_molic_set_intersect', PACKAGE = 'molic', v1, v2)
}

set_union <- function(v1, v2) {
    .Call('_molic_set_union', PACKAGE = 'molic', v1, v2)
}

set_diff <- function(v1, v2) {
    .Call('_molic_set_diff', PACKAGE = 'molic', v1, v2)
}

set_eq <- function(v1, v2) {
    .Call('_molic_set_eq', PACKAGE = 'molic', v1, v2)
}

is_element_present <- function(a, b) {
    .Call('_molic_is_element_present', PACKAGE = 'molic', a, b)
}

is_subseteq <- function(a, b) {
    .Call('_molic_is_subseteq', PACKAGE = 'molic', a, b)
}

